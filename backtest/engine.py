import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import sys
import os

# Add the parent directory to the Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

class BacktestEngine:
    """
    Backtesting engine for trading strategies.
    
    This engine simulates trading based on signals generated by a strategy.
    """
    
    def __init__(self, initial_capital=100000, commission=0.0001, slippage=0.001, risk_free_rate=0.02):
        """
        Initialize the backtesting engine.
        
        Parameters:
        -----------
        initial_capital : float, default 100000
            Initial capital to start trading with
        commission : float, default 0.001
            Commission rate per trade (0.001 = 0.1%)
        slippage : float, default 0.001
            Slippage rate per trade (0.001 = 0.1%)
        risk_free_rate : float, default 0.02
            Annual risk-free rate for performance calculations
        """
        self.initial_capital = initial_capital
        self.commission = commission
        self.slippage = slippage
        self.risk_free_rate = risk_free_rate
        self.reset()
    
    def reset(self):
        """
        Reset the engine to its initial state.
        """
        self.capital = self.initial_capital
        self.position = 0
        self.trades = []
        self.equity_curve = []
    
    def run(self, data, ticker, strategy):
        """
        Run backtest on the data using the specified strategy.
        
        Parameters:
        -----------
        data : DataFrame
            The dataframe containing price data
        ticker : str
            The ticker symbol
        strategy : BaseStrategy
            The strategy to use for generating signals
            
        Returns:
        --------
        DataFrame
            Backtest results including equity curve, returns, etc.
        """
        # Reset the engine
        self.reset()
        
        # Prepare data for the strategy
        prepared_data = strategy.prepare_data(data)
        
        # Generate signals
        signals_data = strategy.generate_signals(prepared_data)
        
        # Create a copy to avoid modifying the original
        df = signals_data.copy()
        
        # Initialize columns for backtest results with explicit float dtype
        df[f'{ticker}_position'] = 0.0
        df[f'{ticker}_equity'] = float(self.initial_capital)
        df[f'{ticker}_cash'] = float(self.initial_capital)
        df[f'{ticker}_holdings'] = 0.0
        df[f'{ticker}_trade'] = 0.0
        df[f'{ticker}_commission'] = 0.0
        df[f'{ticker}_slippage'] = 0.0
        df[f'{ticker}_strategy_return'] = 0.0
        df[f'{ticker}_cum_return'] = 0.0
        
        # Extract close prices
        close_prices = df[f'{ticker}_close']
        
        # Run simulation
        for i in range(1, len(df)):
            # Get current date
            current_date = df.index[i]
            
            # Calculate daily interest rate based on the type of risk_free_rate
            if isinstance(self.risk_free_rate, pd.Series):
                # If we have a Series of daily rates, find the rate for the current date
                # or the nearest previous date
                try:
                    # Get the most recent rate up to current_date
                    rate_idx = self.risk_free_rate.index.get_indexer([current_date], method='pad')[0]
                    if rate_idx >= 0:  # Valid index found
                        annual_rate = self.risk_free_rate.iloc[rate_idx]
                    else:  # No valid index, use default
                        annual_rate = 0.02
                except:
                    # Fallback to default if any error occurs
                    annual_rate = 0.02
                
                # Convert annual rate to daily rate (simple division for daily rates)
                daily_rate = annual_rate / 252
            else:
                # Use constant risk-free rate with compound interest formula
                daily_rate = (1 + self.risk_free_rate) ** (1/252) - 1
            
            # Calculate interest on cash (previous day's cash)
            interest = df.iloc[i-1][f'{ticker}_cash'] * daily_rate
            
            # Set initial position and cash (with interest added)
            df.iloc[i, df.columns.get_loc(f'{ticker}_cash')] = df.iloc[i-1][f'{ticker}_cash'] + interest
            df.iloc[i, df.columns.get_loc(f'{ticker}_position')] = df.iloc[i-1][f'{ticker}_position']
            
            # Get the signal for the current day
            signal = df.iloc[i][f'{ticker}_signal']
            
            # Get position size (if strategy provides it)
            position_size = df.iloc[i].get(f'{ticker}_position_size', signal)
            
            # Execute trade if there's a signal
            if signal != 0:
                # Calculate number of shares to trade
                current_cash = df.iloc[i][f'{ticker}_cash']
                current_position = df.iloc[i][f'{ticker}_position']
                current_price = close_prices.iloc[i]
                
                if signal > 0:  # Buy signal
                    # Calculate total portfolio value
                    total_portfolio_value = current_cash + (current_position * current_price)

                    # Calculate target position based on total portfolio
                    target_position_value = position_size * total_portfolio_value
                    target_position_shares = target_position_value / current_price

                    # Calculate trade size
                    trade_size = target_position_shares - current_position
                                        
                    if trade_size > 0:
                        # Calculate transaction costs
                        commission_cost = trade_size * current_price * self.commission
                        slippage_cost = trade_size * current_price * self.slippage
                        
                        # Update position, cash, and costs
                        df.iloc[i, df.columns.get_loc(f'{ticker}_position')] += trade_size
                        df.iloc[i, df.columns.get_loc(f'{ticker}_cash')] -= (trade_size * current_price + commission_cost + slippage_cost)
                        df.iloc[i, df.columns.get_loc(f'{ticker}_trade')] = trade_size
                        df.iloc[i, df.columns.get_loc(f'{ticker}_commission')] = commission_cost
                        df.iloc[i, df.columns.get_loc(f'{ticker}_slippage')] = slippage_cost
                
                elif signal < 0:  # Sell signal
                    #Calculate total portfolio value
                    total_portfolio_value = current_cash + (current_position * current_price)

                    # For complete exit (traditional approach)
                    #target_position_shares = 0  # Sell everything

                    # OR for a partial reduction approach:
                    target_allocation = max(0, 1 - abs(position_size))  # e.g., position_size=1.0 â†’ 0% allocation
                    target_position_shares = (target_allocation * total_portfolio_value) / current_price

                    # Calculate shares to sell (will be negative)
                    trade_size = target_position_shares - current_position

                    # Only execute if we're reducing our position
                    if trade_size < 0 and current_position > 0:
                        # Calculate transaction costs
                        commission_cost = abs(trade_size) * current_price * self.commission
                        slippage_cost = abs(trade_size) * current_price * self.slippage
                        
                        # Update position, cash, and costs
                        df.iloc[i, df.columns.get_loc(f'{ticker}_position')] += trade_size
                        df.iloc[i, df.columns.get_loc(f'{ticker}_cash')] += (abs(trade_size) * current_price - commission_cost - slippage_cost)
                        df.iloc[i, df.columns.get_loc(f'{ticker}_trade')] = trade_size
                        df.iloc[i, df.columns.get_loc(f'{ticker}_commission')] = commission_cost
                        df.iloc[i, df.columns.get_loc(f'{ticker}_slippage')] = slippage_cost
            
            # Calculate holdings value
            df.iloc[i, df.columns.get_loc(f'{ticker}_holdings')] = df.iloc[i][f'{ticker}_position'] * close_prices.iloc[i]
            
            # Calculate equity
            df.iloc[i, df.columns.get_loc(f'{ticker}_equity')] = df.iloc[i][f'{ticker}_cash'] + df.iloc[i][f'{ticker}_holdings']
            
            # Calculate strategy return
            prev_equity = df.iloc[i-1][f'{ticker}_equity']
            current_equity = df.iloc[i][f'{ticker}_equity']
            df.iloc[i, df.columns.get_loc(f'{ticker}_strategy_return')] = (current_equity / prev_equity) - 1
            
            # Calculate cumulative return
            df.iloc[i, df.columns.get_loc(f'{ticker}_cum_return')] = (current_equity / self.initial_capital) - 1
        
        return df
    
    def get_trades(self, df, ticker):
        """
        Extract trade information from backtest results.
        
        Parameters:
        -----------
        df : DataFrame
            The dataframe containing backtest results
        ticker : str
            The ticker symbol
            
        Returns:
        --------
        DataFrame
            Trade information
        """
        # Extract trades (non-zero trade column)
        trades = df[df[f'{ticker}_trade'] != 0].copy()
        
        # Add trade information
        trades['trade_type'] = trades[f'{ticker}_trade'].apply(lambda x: 'Buy' if x > 0 else 'Sell')
        trades['trade_value'] = trades[f'{ticker}_trade'].abs() * trades[f'{ticker}_close']
        
        return trades
    
    def plot_equity_curve(self, df, ticker, benchmark=None, figsize=(12, 6)):
        """
        Plot equity curve and benchmark (if provided).
        
        Parameters:
        -----------
        df : DataFrame
            The dataframe containing backtest results
        ticker : str
            The ticker symbol
        benchmark : str, default None
            The benchmark ticker symbol
        figsize : tuple, default (12, 6)
            Figure size
            
        Returns:
        --------
        matplotlib.figure.Figure
            The figure object
        """
        fig, ax = plt.subplots(figsize=figsize)
        
        # Plot equity curve
        equity_normalized = df[f'{ticker}_equity'] / self.initial_capital
        ax.plot(equity_normalized, label=f'{ticker} Strategy', linewidth=2)
        
        # Plot buy & hold if requested
        if benchmark:
            buy_hold = df[f'{benchmark}_close'] / df[f'{benchmark}_close'].iloc[0]
            ax.plot(buy_hold, label=f'{benchmark} Buy & Hold', linewidth=2, alpha=0.7)
        else:
            # Use ticker as buy & hold
            buy_hold = df[f'{ticker}_close'] / df[f'{ticker}_close'].iloc[0]
            ax.plot(buy_hold, label=f'{ticker} Buy & Hold', linewidth=2, alpha=0.7)
        
        ax.set_title('Equity Curve', fontsize=14)
        ax.set_ylabel('Normalized Equity', fontsize=12)
        ax.grid(True, alpha=0.3)
        ax.legend()
        
        return fig
    
    def plot_drawdowns(self, df, ticker, figsize=(12, 6)):
        """
        Plot drawdowns over time.
        
        Parameters:
        -----------
        df : DataFrame
            The dataframe containing backtest results
        ticker : str
            The ticker symbol
        figsize : tuple, default (12, 6)
            Figure size
            
        Returns:
        --------
        matplotlib.figure.Figure
            The figure object
        """
        fig, ax = plt.subplots(figsize=figsize)
        
        # Calculate drawdowns
        equity = df[f'{ticker}_equity']
        peak = equity.expanding().max()
        drawdown = (equity / peak) - 1
        
        # Plot drawdowns
        ax.fill_between(drawdown.index, drawdown, 0, color='red', alpha=0.3)
        ax.plot(drawdown, color='red', linewidth=1)
        
        ax.set_title('Strategy Drawdowns', fontsize=14)
        ax.set_ylabel('Drawdown', fontsize=12)
        ax.grid(True, alpha=0.3)
        
        # Add horizontal lines at common drawdown levels
        ax.axhline(y=-0.1, color='gray', linestyle='--', alpha=0.7)
        ax.axhline(y=-0.2, color='gray', linestyle='--', alpha=0.7)
        ax.axhline(y=-0.3, color='gray', linestyle='--', alpha=0.7)
        
        return fig
